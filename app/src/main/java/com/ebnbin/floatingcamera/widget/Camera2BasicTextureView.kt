/*
 * Copyright 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// https://github.com/googlesamples/android-Camera2Basic

package com.ebnbin.floatingcamera.widget

import android.content.Context
import android.graphics.ImageFormat
import android.hardware.camera2.CameraAccessException
import android.hardware.camera2.CameraCaptureSession
import android.hardware.camera2.CameraDevice
import android.hardware.camera2.CaptureRequest
import android.hardware.camera2.TotalCaptureResult
import android.media.ImageReader
import android.util.AttributeSet
import android.util.Log
import android.view.Surface
import java.io.FileOutputStream
import java.io.IOException
import java.util.Arrays

class Camera2BasicTextureView constructor(
        context: Context,
        attrs: AttributeSet? = null,
        defStyle: Int = 0
) : CameraView(context, attrs, defStyle) {

    override fun onTap() {
        post { captureStillPicture() }
    }

    override fun beforeOpenCamera() {
        super.beforeOpenCamera()

        imageReader = ImageReader.newInstance(resolution.width, resolution.height,
                ImageFormat.JPEG, /*maxImages*/ 2).apply {
            setOnImageAvailableListener({
                backgroundHandler.post {
                    val image = it.acquireNextImage()

                    val buffer = image.planes[0].buffer
                    val bytes = ByteArray(buffer.remaining())
                    buffer.get(bytes)
                    var output: FileOutputStream? = null
                    try {
                        output = FileOutputStream(file).apply {
                            write(bytes)
                        }
                    } catch (e: IOException) {
                        Log.e("ebnbin", e.toString())
                    } finally {
                        image.close()
                        output?.let {
                            try {
                                it.close()
                            } catch (e: IOException) {
                                Log.e("ebnbin", e.toString())
                            }
                        }
                    }
                }
            }, backgroundHandler)
        }
    }

    override fun onOpened() {
        super.onOpened()

        createCameraPreviewSession()
    }

    override fun onCloseCamera() {
        super.onCloseCamera()

        captureSession?.close()
        captureSession = null
        imageReader?.close()
        imageReader = null
    }

    //*****************************************************************************************************************

    /**
     * A [CameraCaptureSession] for camera preview.
     */
    private var captureSession: CameraCaptureSession? = null

    /**
     * An [ImageReader] that handles still image capture.
     */
    private var imageReader: ImageReader? = null

    /**
     * [CaptureRequest] generated by previewRequestBuilder.
     */
    private lateinit var previewRequest: CaptureRequest

    /**
     * Creates a new [CameraCaptureSession] for camera preview.
     */
    private fun createCameraPreviewSession() {
        if (null == cameraDevice || !isAvailable || isNotAttachedToWindow()) return
        try {
            // This is the output Surface we need to start preview.
            val surface = Surface(surfaceTexture)

            // Here, we create a CameraCaptureSession for camera preview.
            cameraDevice?.createCaptureSession(Arrays.asList(surface, imageReader?.surface),
                    object : CameraCaptureSession.StateCallback() {

                        override fun onConfigured(cameraCaptureSession: CameraCaptureSession) {
                            // The camera is already closed
                            if (cameraDevice == null) return

                            // When the session is ready, we start displaying the preview.
                            captureSession = cameraCaptureSession
                            try {
                                // We set up a CaptureRequest.Builder with the output Surface.
                                val previewRequestBuilder = cameraDevice!!.createCaptureRequest(
                                        CameraDevice.TEMPLATE_PREVIEW
                                )
                                previewRequestBuilder.addTarget(surface)

                                // Auto focus should be continuous for camera preview.
                                previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,
                                        CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)

                                // Finally, we start displaying the camera preview.
                                previewRequest = previewRequestBuilder.build()
                                captureSession?.setRepeatingRequest(previewRequest,
                                        null, backgroundHandler)
                            } catch (e: CameraAccessException) {
                                Log.e("ebnbin", e.toString())
                            }

                        }

                        override fun onConfigureFailed(session: CameraCaptureSession) {
                            toast("Failed")
                        }
                    }, null)
        } catch (e: CameraAccessException) {
            Log.e("ebnbin", e.toString())
        }

    }

    /**
     * Capture a still picture. This method should be called when we get a response in
     * [.captureCallback] from both [.lockFocus].
     */
    private fun captureStillPicture() {
        try {
            if (isNotAttachedToWindow() || cameraDevice == null) return

            // This is the CaptureRequest.Builder that we use to take a picture.
            val captureBuilder = cameraDevice?.createCaptureRequest(
                    CameraDevice.TEMPLATE_STILL_CAPTURE)?.apply {
                addTarget(imageReader?.surface)

                // Sensor orientation is 90 for most devices, or 270 for some devices (eg. Nexus 5X)
                // We have to take that into account and rotate JPEG properly.
                // For devices with orientation of 90, we return our mapping from ORIENTATIONS.
                // For devices with orientation of 270, we need to rotate the JPEG 180 degrees.
                set(CaptureRequest.JPEG_ORIENTATION, device.getOrientation())

                // Use the same AE and AF modes as the preview.
                set(CaptureRequest.CONTROL_AF_MODE,
                        CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)
            }

            val captureCallback = object : CameraCaptureSession.CaptureCallback() {
                override fun onCaptureStarted(session: CameraCaptureSession?, request: CaptureRequest?,
                        timestamp: Long, frameNumber: Long) {
                    super.onCaptureStarted(session, request, timestamp, frameNumber)

                    setUpFile(".jpg")
                }

                override fun onCaptureCompleted(session: CameraCaptureSession,
                        request: CaptureRequest,
                        result: TotalCaptureResult) {
                    toastFile()

                    try {
                        // After this, the camera will go back to the normal state of preview.
                        captureSession?.setRepeatingRequest(previewRequest, null,
                                backgroundHandler)
                    } catch (e: CameraAccessException) {
                        Log.e("ebnbin", e.toString())
                    }
                }
            }

            captureSession?.apply {
                stopRepeating()
                abortCaptures()
                capture(captureBuilder?.build(), captureCallback, null)
            }
        } catch (e: CameraAccessException) {
            Log.e("ebnbin", e.toString())
        }

    }
}
